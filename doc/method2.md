## 词法分析器生成器子模块构造实践
##### 软件学院 陈睿 141250013

### 目标
1. 尝试进行词法分析器生成器的构造
2. 更深入理解龙书上相关算法，并自己通过代码进行实现
3. 锻炼一下自己的能力

### 主要内容
本报告主要描述了词法分析器生成器中一部分子模块的构造，主要包括：

1. 正则表达式推出NFA
2. NFA推出DFA
3. 以及以上2个过程的具体实现过程
4. 从中的收获

### 环境
- Mac OS
- Clion + MinGW (gcc)
- MakeFile

### 假设
1. 输入正则表达式仅包含连接、选择、闭包运算
2. 仅包含a-z的符号
3. 假设e边用`&`记号表示

### 思路
- 整体思路
	- 考虑到之前构造简易词法分析器的过程，最终核心还是要产生确定的有限状态自动机，即DFA，之后应该就可以生成相应的模板代码去用于分析程序。
	- 因此，主要分为由RE构造出DFA和由DFA生成模板代码2部分
	- 由于时间问题，这里主要实现了由RE构造出DFA的过程，借鉴龙书上相关算法，结合一部分自己所学知识即可。
- 程序流程
	1. 输入正则表达式
	2. 对输入的正则表达式进行符号化补全，加入相关连接符号
	3. 将中缀的正则表达式转换为后缀形式
	4. 对确定的后缀表达式进行RE->NFA的过程
	5. NFA->DFA
	6. 输出所有DFA状态

### 实现
##### 数据结构
	//图的边集，模拟链表实现
	struct edge{
    	int des;
    	char path;
    	int next_edge;
	}e[max_edges];
	int e_nums = 0;
	//状态
	struct sta{
    	int first_edge;
    	bool is_start;
    	bool is_end;
    	set<int> rep;
	}state[max_states];
	int state_nums = 0;
	//进行中缀转后缀的符号栈和操作数栈
	stack<string> stack_char;
	stack<char> stack_op;
	//所有可能边集
	set<char> path_set;
##### 算法
- RE->NFA
	1. 对输入的中缀正则表达式补全`.`（连接符号），用于进行后缀表达式的转换。
		- 只需要判断当前如果是字符，那么如果前一个符号为`)`,`*`,`字符`中的一种就加入`.`
	2. 进行中缀表达式转后缀表达式
		- 通过符号栈和操作数栈来实现，由于3个操作符无优先级，且*为单目操作符。
		- 先判断是否为`*`，如果是，则直接对操作数栈中栈顶元素+`*`在压入栈中
		- 如果是`)`，则一直进行出栈操作直到匹配到`)`
		- 如果是`.`或`|`则在栈不空的情况下进行出栈操作
		- 其他情况进栈
		- 注意符号栈进行出栈操作实际上需要对操作数栈进行一个`combine`操作，再push回去
	3. 后缀表达式转NFA
		- 利用`bottom-up`的思想，构建分析树，再根据不同操作符创建状态，具体如下。
		- 连接操作
		- 选择操作
		- 闭包操作
		- 注意，这里直接把状态作为点，转换作为边进行有向图的构建，加入相应e边进行构造
- NFA->DFA
	- 利用`子集构造法`
	- 首先状态为NFA中初始状态的e-closure，然后逐步求出各个状态，具体如书上伪代码，见下图：
	- 注意，这边采用`STL<queue>`作为数据结构，并采用广度优先遍历进行状态生成。
	- 并采用`STL<set>`作为记录状态集的数据结构，防止重复状态。
	- 其中计算e-closure的方法也如书上所示伪代码，见下图：
	- 这里同样采用`STL<queue>`，采用广度优先遍历进行一层一层e边的迭代。

### 困难与解决
1. 后缀表达式转NFA时，如何记录中间产生的各个状态。
	- 实际上，从语法分析树可以看到，最多只会有2个当前状态集，并且当前状态集实际上只有start状态和end状态是会被后续转换所用到的，于是只需要用4个变量表示即可。如我代码中：
	
	 		int in1 = -1; // start state 1
    		int out1  = -1; // end state 1
    		int in2 = -1; // start state 2
    		int out2 = -1; // end state 2
2. NFA转DFA时，如何记录当前状态集所对应的状态号？因为没有建立对应状态集的数据结构，状态集实际上也是一个状态。
	- 采用多一个`STL<vector>`的方式，跟踪记录相应状态号。
	
			queue<set<int>> q;
    		queue<int> q_state_num; //记录访问过的集合的state number
    		vector<set<int>> vis;
    		vector<int> vis_state_num; //记录访问过的集合的state number

### 测试
测试输入
测试输出
### 总结与收获
1. 感觉复习了一些以前学过的算法，如BFS，中缀转后缀等
2. 感受到了词法分析器生成器的有趣之处，希望有空可以实现一个自己的简单分析生成器。
3. 没有了一开始看到lex生成出一个分析代码的模板出来那种震惊了，感觉自己也可以实现~


